import { Meta, Canvas, ArgTypes, Source } from '@storybook/blocks';

import * as Stories from './SplitLayout.stories';

<Meta of={Stories} />

# SplitLayout

## Overview

The SplitLayout component is a layout element that enables the division of the screen
into multiple blocks that are resizables.
It is based on [split.js](https://split.js.org/), so you could use all of the
properties of split.js.
With SplitLayout, you can easily create a split view layout, allowing users to view
multiple pieces of content simultaneously.

It can also be nested, allowing for the creation of more complex layouts, and
split vertically or horizontally, depending on the needs of the user interface.

## How to import

<Source code={`import { SplitLayout } from '@devoinc/genesys-ui';`} />

## Basic usage

Add the desired blocks as direct children of the SplitLayout. For each block a resizable area is automatically created.
Usually we need to define a height for the parent container of the `SplitLayout` if we want a pre-defined height
regardless of whether there is content or not.

<Canvas of={Stories.Base} />

Anyway, the resizable areas will adapt their height to their contents, although there is no defined height.

<Canvas of={Stories.BaseWithoutHeight} />

## Without minSize

If you don't define a minSize for the blocks, when we resize one to the maximum the other ends in
`width: 0` or `height: 0`, so we recommend adding `overflow: hidden` to the children blocks,
to avoid maintaining visible undesired contents or spaces. In the same way, you should also
add the internal padding to a nested children of the block, instead of directly to it, because of
the box model, which maintains the space of the padding although the width or height is '0'.

This is an example without minSize, but with padding in the children blocks, instead of in a nested one,
and without applying `overflow:hidden`. We can see how the content is not completely hidden
when we resize the other one to the maximum:

<Canvas of={Stories.WithoutMinSizeBad} />

In this example we apply `overflow:hidden` and the padding is defined in nested blocks, so we can see how the content
is completely hidden when we resize the other one to the maximum:

<Canvas of={Stories.WithoutMinSizeGood} />

## Three blocks

This an example with three blocks with different sizes which define the widths of the blocks:

<Canvas of={Stories.Three} />

## Nested

Yoi can create nested resizable areas simply nesting `SplitLayout`components:

<Canvas of={Stories.Nested} />

## Dynamic content

<Canvas of={Stories.HiddenContent} />

## Props

<ArgTypes of={Stories} />
